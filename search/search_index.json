{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JVol","text":"<p>This is the documentation for JVol.</p> <p>JVol is an experimental image file format for 3D images compressed using a simplified version of the JPEG algorithm. The compression is lossy and therefore not suitable for all applications, e.g., diagnosis or quantitative analysis.</p> <p>There are several situations in which preserving full quality is not crucial and JVol can be useful:</p> <ul> <li>Data needs to be transmitted quickly, or over a slow network</li> <li>Storage space is limited</li> <li>Tests for continuous integration</li> <li>Quick debugging and development</li> <li>Online demos</li> </ul>"},{"location":"cli-tool/","title":"CLI tool","text":""},{"location":"cli-tool/#jvol","title":"jvol","text":"<p>Tool for converting medical images to and from JPEG-encoded volumes.</p> <p>Usage:</p> <pre><code>main [OPTIONS] INPUT_PATH OUTPUT_PATH\n</code></pre> <p>Options:</p> <pre><code>  INPUT_PATH                      \\[required]\n  OUTPUT_PATH                     \\[required]\n  -q, --quality INTEGER RANGE     Quality of the JPEG encoding, between 1 and\n                                  100.  \\[default: 60; 1&lt;=x&lt;=100]\n  -b, --block-size INTEGER RANGE  Size of the blocks to use for encoding.\n                                  Quality is higher with larger blocks, but so\n                                  is the file size.  \\[default: 8; x&gt;=2]\n  -v, --verbose                   Enable verbose logging. Use -vv for debug\n                                  logging.  \\[default: 0]\n  --install-completion            Install completion for the current shell.\n  --show-completion               Show completion for the current shell, to\n                                  copy it or customize the installation.\n</code></pre>"},{"location":"compression/","title":"Compression ratio and artifacts","text":""},{"location":"compression/#compression-ratio-and-artifacts","title":"Compression ratio and artifacts\u00b6","text":"<p>TODO</p>"},{"location":"decoding/","title":"Decoding algorithm","text":""},{"location":"decoding/#decoding-algorithm","title":"Decoding algorithm\u00b6","text":"<p>TODO</p>"},{"location":"encoding/","title":"Encoding algorithm","text":""},{"location":"encoding/#encoding-algorithm","title":"Encoding algorithm\u00b6","text":"<p>JVol files are encoded using a simplified version of the JPEG algorithm, adapted for 3D images.</p>"},{"location":"encoding/#color","title":"Color\u00b6","text":"<p>For now, only single-channel images are supported. Therefore, no color space conversion or chroma subsampling is performed.</p>"},{"location":"encoding/#block-splitting","title":"Block splitting\u00b6","text":"<p>The array/volume of size $I \\times J \\times K$ is split into subvolumes/blocks of size $B \\times B \\times B$. If the array is not a multiple of $B$ along a dimension, it is padded using NumPy's <code>reflect</code> mode.</p> <p>Here's an exaggerated illustration of reflection padding (in 2D, for visualization purposes):</p>"},{"location":"encoding/#discrete-cosine-transform","title":"Discrete cosine transform\u00b6","text":"<p>TODO</p>"},{"location":"encoding/#quantization","title":"Quantization\u00b6","text":"<p>TODO</p>"},{"location":"encoding/#entropy-coding","title":"Entropy coding\u00b6","text":"<p>TODO</p>"},{"location":"faq/","title":"Frequently asked questions","text":""},{"location":"faq/#when-should-i-use-jvol","title":"When should I use JVol?","text":"<p>Lossy compression is typically used when a file can afford to lose some data, and/or if storage space needs to be drastically \"freed up\".</p> <ul> <li>Adobe.com</li> </ul>"},{"location":"faq/#when-should-i-not-use-jvol","title":"When should I not use JVol?","text":"<p>JVol is not intended for clinical use.</p>"},{"location":"faq/#how-do-i-get-started","title":"How do I get started?","text":"<p>The best way to get started is to read the Getting started guide.</p>"},{"location":"faq/#how-do-i-get-help","title":"How do I get help?","text":"<p>If you have a question, please open a discussion. If you would like to request a feature or report a bug, please submit an issue. If you are reporting a bug, please make sure to mention what you got and what you expected.</p>"},{"location":"faq/#what-frameworks-does-jvol-use-under-the-hood","title":"What frameworks does JVol use under the hood?","text":"<p>JVol uses NumPy and SciPy for for numerical computations. The command line is implemented using Typer, and ITK is used to read and write medical images in standard formats.</p> <p>Other libraries that are used:</p> <ul> <li><code>humanize</code> for human-readable messages.</li> <li><code>einops</code> for human-readable code.</li> <li><code>transforms3d</code> for human-readable transforms manipulation.</li> </ul>"},{"location":"file-format/","title":"File format","text":"<p>TODO: inspect contents dynamically</p>"},{"location":"file-format/#file-format","title":"File format\u00b6","text":"<p>Under the hood, JVol files are <code>.npz</code> files. From NumPy's documentation:</p> <p>The <code>.npz</code> file format is a zipped archive of files named after the variables they contain. The archive is compressed with <code>zipfile.ZIP_DEFLATED</code> and each file in the archive contains one variable in <code>.npy</code> format. For a description of the <code>.npy</code> format, see <code>numpy.lib.format</code>.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>JVol can be installed using Pip Installs Packages (PIP):</p> <pre>pip install git+https://github.com/fepegar/jvol.git\n</pre> <p>Let's install it in this notebook.</p> In\u00a0[1]: Copied! <pre>%%capture\n%pip install git+https://github.com/fepegar/jvol.git\n</pre> %%capture %pip install git+https://github.com/fepegar/jvol.git <p>Let's first download some NIfTI data from the Colin 27 Average Brain 2008 MNI template.</p> In\u00a0[2]: Copied! <pre>%%bash\ncurl -O -s https://packages.bic.mni.mcgill.ca/mni-models/colin27/mni_colin27_2008_nifti.zip\nunzip -q -o mni_colin27_2008_nifti.zip\nls -lh *.nii\n</pre> %%bash curl -O -s https://packages.bic.mni.mcgill.ca/mni-models/colin27/mni_colin27_2008_nifti.zip unzip -q -o mni_colin27_2008_nifti.zip ls -lh *.nii <pre>-rw-r--r-- 1 runner docker 109M Jul 10  2012 colin27_cls_tal_hires.nii\n-rw-r--r-- 1 runner docker 21</pre> <pre>7M Jul 10  2012 colin27_pd_tal_hires.nii\n-rw-r--r-- 1 runner docker 217M Jul 10  2012 colin27_t1_tal</pre> <pre>_hires.nii\n-rw-r--r-- 1 runner docker 217M Jul 10  2012 colin27_t2_tal_hires.nii\n</pre> <p>We'll use the <code>jvol</code> command to encode an existing image. Use <code>jvol --help</code> to get a full list of features of the CLI tool.</p> In\u00a0[3]: Copied! <pre>%%bash\njvol --help\n</pre> %%bash jvol --help <pre>                                                                                \n \u001b[</pre> <pre>1;33mUsage: jvol [OPTIONS] INPUT_PATH OUTPUT_PATH                                  \u001b</pre> <pre>[0m \n                                                                                \u001b[0</pre> <pre>m\n</pre> <pre> Tool for converting medical images to and from JPEG-encoded volumes.           \n                   </pre> <pre>                                                             \n                                      </pre> <pre>                                          \n</pre> <pre>\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ufffd</pre> <pre>\ufffd\ufffd\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    input_path       \u001b[1;33</pre> <pre>mFILE  [default: None] [required]                       \u2502\n\u2502\u001b[</pre> <pre>0m *    output_path      FILE  [default: None] [required]    </pre> <pre>                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ufffd</pre> <pre>\ufffd\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ufffd</pre> <pre>\ufffd\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --quality  </pre> <pre>           -q      INTEGER RANGE          Quality of the JPEG     \u2502\n</pre> <pre>\u2502                               [1&lt;=x&lt;=100]            </pre> <pre>encoding, between 1 and \u2502\n\u2502                                                     </pre> <pre> 100.                    \u2502\n\u2502                                                    </pre> <pre>  [default: 60]           \u2502\n\u2502 --block-size\u001b</pre> <pre>[0m          -b      INTEGER RANGE [x&gt;=2]   Size of th</pre> <pre>e blocks to   \u2502\n\u2502                                                      use for e</pre> <pre>ncoding.       \u2502\n\u2502                                                      Quality </pre> <pre>is higher with  \u2502\n\u2502                                                      larger </pre> <pre>blocks, but so   \u2502\n\u2502                                                      is the</pre> <pre> file size.       \u2502\n\u2502                                                      [</pre> <pre>default: 8]            \u2502\n\u2502 --verbose             \u001b[1;3</pre> <pre>2m-v      INTEGER                Enable verbose logging. \u2502\n\u2502     </pre> <pre>                                                 Use -vv for debug       \u2502\n</pre> <pre>\u2502                                                      logging.                \u2502\n\u001b[2</pre> <pre>m\u2502                                                      [default: 0]            \ufffd</pre> <pre>\ufffd\n\u2502 --install-completion                      </pre> <pre>           Install completion for  \u2502\n\u2502                                      </pre> <pre>                the current shell.      \u2502\n\u2502 --show-</pre> <pre>completion                                    Show completion for the \u2502\n\u001b[2</pre> <pre>m\u2502                                                      current shell, to copy  \u2502\n\u001b[</pre> <pre>2m\u2502                                                      it or customize the     \u2502\n\u001b</pre> <pre>[2m\u2502                                                      installation.           \u2502\n</pre> <pre>\u2502 --help                                               Sh</pre> <pre>ow this message and   \u2502\n\u2502                                                      e</pre> <pre>xit.                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ufffd</pre> <pre>\ufffd\ufffd\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ufffd</pre> <pre>\ufffd\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\n</pre> <p>Let's encode an image with the default settings.</p> In\u00a0[4]: Copied! <pre>%%bash\njvol colin27_t1_tal_hires.nii colin27_t1_tal_hires.jvol\n</pre> %%bash jvol colin27_t1_tal_hires.nii colin27_t1_tal_hires.jvol <p>Let's use Python to check how we've done. We'll also install TorchIO to read some of the image metadata.</p> In\u00a0[5]: Copied! <pre>%%capture\n%pip install \"torchio[plot]\"\n</pre> %%capture %pip install \"torchio[plot]\" In\u00a0[6]: Copied! <pre>from pathlib import Path\nimport numpy as np\nimport torchio as tio\nfrom humanize import naturalsize\n\n\ndef compare_sizes(original_path: Path, compressed_path: Path) -&gt; None:\n    def get_num_pixels(path):\n        return np.prod(tio.ScalarImage(path).shape)\n\n    num_pixels = get_num_pixels(original_path)\n    original_size = original_path.stat().st_size\n    original_bits_per_pixel = 8 * original_size / num_pixels\n    compressed_size = compressed_path.stat().st_size\n    compr_bits_per_pixel = 8 * compressed_size / num_pixels\n\n    compression_ratio = original_size / compressed_size\n    nat_orig = naturalsize(original_size)\n    nat_comp = naturalsize(compressed_size)\n    print(f\"Original file size: {nat_orig} ({original_bits_per_pixel:.2f} bits/pixel)\")\n    print(f\"Compressed file size: {nat_comp} ({compr_bits_per_pixel:.2f} bits/pixel)\")\n    print(f\"Compression ratio: {compression_ratio:.1f}\u00d7\")\n\n\nnii_path = Path(\"colin27_t1_tal_hires.nii\")\njvol_path = Path(\"colin27_t1_tal_hires.jvol\")\n\ncompare_sizes(nii_path, jvol_path)\n</pre> from pathlib import Path import numpy as np import torchio as tio from humanize import naturalsize   def compare_sizes(original_path: Path, compressed_path: Path) -&gt; None:     def get_num_pixels(path):         return np.prod(tio.ScalarImage(path).shape)      num_pixels = get_num_pixels(original_path)     original_size = original_path.stat().st_size     original_bits_per_pixel = 8 * original_size / num_pixels     compressed_size = compressed_path.stat().st_size     compr_bits_per_pixel = 8 * compressed_size / num_pixels      compression_ratio = original_size / compressed_size     nat_orig = naturalsize(original_size)     nat_comp = naturalsize(compressed_size)     print(f\"Original file size: {nat_orig} ({original_bits_per_pixel:.2f} bits/pixel)\")     print(f\"Compressed file size: {nat_comp} ({compr_bits_per_pixel:.2f} bits/pixel)\")     print(f\"Compression ratio: {compression_ratio:.1f}\u00d7\")   nii_path = Path(\"colin27_t1_tal_hires.nii\") jvol_path = Path(\"colin27_t1_tal_hires.jvol\")  compare_sizes(nii_path, jvol_path) <pre>Original file size: 227.5 MB (32.00 bits/pixel)\nCompressed file size: 8.0 MB (1.12 bits/pixel)\nCompression ratio: 28.6\u00d7\n</pre> <p>Not bad! Let's compare with lossless compression.</p> In\u00a0[7]: Copied! <pre>%%bash\ngzip -k -f colin27_t1_tal_hires.nii\n</pre> %%bash gzip -k -f colin27_t1_tal_hires.nii In\u00a0[8]: Copied! <pre>nii_gz_path = Path(\"colin27_t1_tal_hires.nii.gz\")\n\ncompare_sizes(nii_path, nii_gz_path)\n</pre> nii_gz_path = Path(\"colin27_t1_tal_hires.nii.gz\")  compare_sizes(nii_path, nii_gz_path) <pre>Original file size: 227.5 MB (32.00 bits/pixel)\nCompressed file size: 103.0 MB (14.49 bits/pixel)\nCompression ratio: 2.2\u00d7\n</pre> <p>It seems that we're doing much better!</p> <p>You might be wondering about the visual quality of the compressed image, compared to the original. Let's use TorchIO to visualize both images.</p> <p>We'll need to convert the compressed image to a format that TorchIO can read. We can use <code>jvol</code> to decode the image back to NIfTI.</p> In\u00a0[9]: Copied! <pre>%%bash\njvol colin27_t1_tal_hires.jvol colin27_t1_tal_hires_from_jvol.nii\n</pre> %%bash jvol colin27_t1_tal_hires.jvol colin27_t1_tal_hires_from_jvol.nii In\u00a0[10]: Copied! <pre>def compare_images(original_path: Path, compressed_path: Path) -&gt; None:\n    original = tio.ScalarImage(original_path)\n    compressed = tio.ScalarImage(compressed_path)\n    both = tio.Subject({\"Original\": original, \"Compressed\": compressed})\n    both.plot(figsize=(10, 6))\n\n\nfrom_jvol_path = Path(\"colin27_t1_tal_hires_from_jvol.nii\")\ncompare_images(nii_path, from_jvol_path)\n</pre> def compare_images(original_path: Path, compressed_path: Path) -&gt; None:     original = tio.ScalarImage(original_path)     compressed = tio.ScalarImage(compressed_path)     both = tio.Subject({\"Original\": original, \"Compressed\": compressed})     both.plot(figsize=(10, 6))   from_jvol_path = Path(\"colin27_t1_tal_hires_from_jvol.nii\") compare_images(nii_path, from_jvol_path) <p>They look quite similar, so it seems that this amount of compression might be acceptable for certain applications. Can we push the compression ratio even further? Let's use a smaller quality setting.</p> In\u00a0[11]: Copied! <pre>%%bash\njvol colin27_t1_tal_hires.nii colin27_t1_tal_hires_low_quality.jvol --quality 5\n</pre> %%bash jvol colin27_t1_tal_hires.nii colin27_t1_tal_hires_low_quality.jvol --quality 5 <p>Again, let's convert back so TorchIO can read it.</p> In\u00a0[12]: Copied! <pre>%%bash\njvol colin27_t1_tal_hires_low_quality.jvol colin27_t1_tal_hires_low_quality.nii\n</pre> %%bash jvol colin27_t1_tal_hires_low_quality.jvol colin27_t1_tal_hires_low_quality.nii In\u00a0[13]: Copied! <pre>from_jvol_tiny_path = Path(\"colin27_t1_tal_hires_low_quality.nii\")\ncompare_images(nii_path, from_jvol_tiny_path)\n</pre> from_jvol_tiny_path = Path(\"colin27_t1_tal_hires_low_quality.nii\") compare_images(nii_path, from_jvol_tiny_path) <p>The artifacts are slightly noticeable this time, but the image is visually still very similar. Let's see how much we've compressed the original image.</p> In\u00a0[14]: Copied! <pre>jvol_tiny_path = Path(\"colin27_t1_tal_hires_low_quality.jvol\")\ncompare_sizes(nii_path, jvol_tiny_path)\n</pre> jvol_tiny_path = Path(\"colin27_t1_tal_hires_low_quality.jvol\") compare_sizes(nii_path, jvol_tiny_path) <pre>Original file size: 227.5 MB (32.00 bits/pixel)\nCompressed file size: 981.3 kB (0.14 bits/pixel)\nCompression ratio: 231.8\u00d7\n</pre>"},{"location":"getting-started/#getting-started","title":"Getting started\u00b6","text":""},{"location":"getting-started/#installation","title":"Installation\u00b6","text":""},{"location":"getting-started/#usage","title":"Usage\u00b6","text":""},{"location":"jvol/","title":"<code>JpegVolume</code> class","text":"<p>Base class for saving and loading JPEG-encoded volumes.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ArrayLike</code> <p>3D NumPy array.</p> required <code>ijk_to_ras</code> <code>ArrayLike | None</code> <p>4\u00d74 affine transformation matrix containing the mapping from voxel indices to RAS+ (left \u2192 right, posterior \u2192 anterior, inferior \u2192 superior) coordinates. If not specified, the identity matrix is used.</p> <code>None</code> Tip <p>To learn more about coordinates systems, check the following resources:</p> <ul> <li>NiBabel's Coordinate systems and affines,</li> <li>3D Slicer's Coordinate systems,</li> <li>FSL's docs (see \"Background information on NIfTI Orientation\")</li> </ul> Source code in <code>src/jvol/jvol.py</code> <pre><code>class JpegVolume:\n    \"\"\"Base class for saving and loading JPEG-encoded volumes.\n\n    Args:\n        array: 3D NumPy array.\n        ijk_to_ras: 4\u00d74 affine transformation matrix containing the mapping\n            from voxel indices to RAS+ (left \u2192 right, posterior \u2192 anterior,\n            inferior \u2192 superior) coordinates. If not specified, the identity\n            matrix is used.\n\n    Tip:\n        To learn more about coordinates systems, check the following resources:\n\n        - [NiBabel](https://nipy.org/nibabel/)'s [Coordinate systems and affines](https://nipy.org/nibabel/coordinate_systems.html),\n        - [3D Slicer](https://www.slicer.org/)'s [Coordinate systems](https://slicer.readthedocs.io/en/latest/user_guide/coordinate_systems.html),\n        - [FSL](https://fsl.fmrib.ox.ac.uk/)'s [docs (see \"Background information on NIfTI Orientation\")](https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/Orientation%20Explained)\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        array: npt.ArrayLike,\n        ijk_to_ras: npt.ArrayLike | None = None,\n    ):\n        self.array = np.array(array)\n        if ijk_to_ras is None:\n            ijk_to_ras = np.eye(4)\n        self.ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)\n        if self.array.ndim != 3:\n            raise ValueError(\n                f\"Array must have 3 dimensions, got shape {self.array.shape}\"\n            )\n        if self.ijk_to_ras.shape != (4, 4):\n            raise ValueError(\n                f\"ijk_to_ras must have shape (4, 4), got {self.ijk_to_ras.shape}\"\n            )\n        assert self.ijk_to_ras.shape == (4, 4)\n\n    @classmethod\n    def open(cls, path: TypePath) -&gt; JpegVolume:\n        \"\"\"Open a JVol file.\n\n        Args:\n            path: Path to a file with `'.jvol'` extension.\n        \"\"\"\n        path = Path(path)\n        if not path.is_file():\n            raise FileNotFoundError(f'File not found: \"{path}\"')\n        if path.suffix != \".jvol\":\n            raise ValueError(f'File must have .jvol extension, got \"{path}\"')\n\n        return cls(*open_jvol(path))\n\n    def save(self, path: TypePath, block_size: int = 8, quality: int = 60) -&gt; None:\n        \"\"\"Save the image using a lossy encoding algorithm for compression.\n\n        Args:\n            path: Output path with `.jvol` extension.\n            block_size: Size of the blocks to use for encoding. Higher\n                values result in better quality, but larger file sizes.\n            quality: Quality of the JPEG encoding, between 1 and 100. Higher\n                values result in better quality, but larger file sizes.\n\n        Raises:\n            ValueError: If the quality is not an integer between 1 and 100.\n            ValueError: If the block size is not a positive integer.\n        \"\"\"\n        if quality != int(quality):\n            raise ValueError(f\"Quality must be an integer, got {quality}\")\n        if not 1 &lt;= quality &lt;= 100:\n            raise ValueError(f\"Quality must be between 1 and 100, got {quality}\")\n\n        if block_size != int(block_size):\n            raise ValueError(f\"Block size must be an integer, got {block_size}\")\n        if block_size &lt;= 0:\n            raise ValueError(f\"Block size must be positive, got {block_size}\")\n\n        path = Path(path)\n\n        save_jvol(\n            self.array,\n            self.ijk_to_ras,\n            path,\n            block_size=block_size,\n            quality=quality,\n        )\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        # Get attribute from the JpegVolume or the underlying array\n        try:\n            return super().__getattribute__(name)\n        except AttributeError as e:\n            try:\n                return getattr(self.array, name)\n            except AttributeError:\n                raise e\n</code></pre>"},{"location":"jvol/#jvol.JpegVolume.array","title":"<code>array = np.array(array)</code>  <code>instance-attribute</code>","text":""},{"location":"jvol/#jvol.JpegVolume.ijk_to_ras","title":"<code>ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)</code>  <code>instance-attribute</code>","text":""},{"location":"jvol/#jvol.JpegVolume.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"Source code in <code>src/jvol/jvol.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; Any:\n    # Get attribute from the JpegVolume or the underlying array\n    try:\n        return super().__getattribute__(name)\n    except AttributeError as e:\n        try:\n            return getattr(self.array, name)\n        except AttributeError:\n            raise e\n</code></pre>"},{"location":"jvol/#jvol.JpegVolume.__init__","title":"<code>__init__(array, ijk_to_ras=None)</code>","text":"Source code in <code>src/jvol/jvol.py</code> <pre><code>def __init__(\n    self,\n    array: npt.ArrayLike,\n    ijk_to_ras: npt.ArrayLike | None = None,\n):\n    self.array = np.array(array)\n    if ijk_to_ras is None:\n        ijk_to_ras = np.eye(4)\n    self.ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)\n    if self.array.ndim != 3:\n        raise ValueError(\n            f\"Array must have 3 dimensions, got shape {self.array.shape}\"\n        )\n    if self.ijk_to_ras.shape != (4, 4):\n        raise ValueError(\n            f\"ijk_to_ras must have shape (4, 4), got {self.ijk_to_ras.shape}\"\n        )\n    assert self.ijk_to_ras.shape == (4, 4)\n</code></pre>"},{"location":"jvol/#jvol.JpegVolume.open","title":"<code>open(path)</code>  <code>classmethod</code>","text":"<p>Open a JVol file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>TypePath</code> <p>Path to a file with <code>'.jvol'</code> extension.</p> required Source code in <code>src/jvol/jvol.py</code> <pre><code>@classmethod\ndef open(cls, path: TypePath) -&gt; JpegVolume:\n    \"\"\"Open a JVol file.\n\n    Args:\n        path: Path to a file with `'.jvol'` extension.\n    \"\"\"\n    path = Path(path)\n    if not path.is_file():\n        raise FileNotFoundError(f'File not found: \"{path}\"')\n    if path.suffix != \".jvol\":\n        raise ValueError(f'File must have .jvol extension, got \"{path}\"')\n\n    return cls(*open_jvol(path))\n</code></pre>"},{"location":"jvol/#jvol.JpegVolume.save","title":"<code>save(path, block_size=8, quality=60)</code>","text":"<p>Save the image using a lossy encoding algorithm for compression.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>TypePath</code> <p>Output path with <code>.jvol</code> extension.</p> required <code>block_size</code> <code>int</code> <p>Size of the blocks to use for encoding. Higher values result in better quality, but larger file sizes.</p> <code>8</code> <code>quality</code> <code>int</code> <p>Quality of the JPEG encoding, between 1 and 100. Higher values result in better quality, but larger file sizes.</p> <code>60</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quality is not an integer between 1 and 100.</p> <code>ValueError</code> <p>If the block size is not a positive integer.</p> Source code in <code>src/jvol/jvol.py</code> <pre><code>def save(self, path: TypePath, block_size: int = 8, quality: int = 60) -&gt; None:\n    \"\"\"Save the image using a lossy encoding algorithm for compression.\n\n    Args:\n        path: Output path with `.jvol` extension.\n        block_size: Size of the blocks to use for encoding. Higher\n            values result in better quality, but larger file sizes.\n        quality: Quality of the JPEG encoding, between 1 and 100. Higher\n            values result in better quality, but larger file sizes.\n\n    Raises:\n        ValueError: If the quality is not an integer between 1 and 100.\n        ValueError: If the block size is not a positive integer.\n    \"\"\"\n    if quality != int(quality):\n        raise ValueError(f\"Quality must be an integer, got {quality}\")\n    if not 1 &lt;= quality &lt;= 100:\n        raise ValueError(f\"Quality must be between 1 and 100, got {quality}\")\n\n    if block_size != int(block_size):\n        raise ValueError(f\"Block size must be an integer, got {block_size}\")\n    if block_size &lt;= 0:\n        raise ValueError(f\"Block size must be positive, got {block_size}\")\n\n    path = Path(path)\n\n    save_jvol(\n        self.array,\n        self.ijk_to_ras,\n        path,\n        block_size=block_size,\n        quality=quality,\n    )\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>jvol<ul> <li>cli<ul> <li>convert</li> </ul> </li> <li>decoding</li> <li>encoding</li> <li>io</li> <li>jvol</li> <li>timer</li> <li>transforms</li> <li>types</li> </ul> </li> </ul>"},{"location":"reference/jvol/","title":"jvol","text":""},{"location":"reference/jvol/#jvol.__all__","title":"<code>__all__ = ['JpegVolume', 'open_jvol', 'save_jvol']</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/#jvol.__version__","title":"<code>__version__ = '0.1.0'</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/#jvol.JpegVolume","title":"<code>JpegVolume</code>","text":"<p>Base class for saving and loading JPEG-encoded volumes.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ArrayLike</code> <p>3D NumPy array.</p> required <code>ijk_to_ras</code> <code>ArrayLike | None</code> <p>4\u00d74 affine transformation matrix containing the mapping from voxel indices to RAS+ (left \u2192 right, posterior \u2192 anterior, inferior \u2192 superior) coordinates. If not specified, the identity matrix is used.</p> <code>None</code> Tip <p>To learn more about coordinates systems, check the following resources:</p> <ul> <li>NiBabel's Coordinate systems and affines,</li> <li>3D Slicer's Coordinate systems,</li> <li>FSL's docs (see \"Background information on NIfTI Orientation\")</li> </ul> Source code in <code>src/jvol/jvol.py</code> <pre><code>class JpegVolume:\n    \"\"\"Base class for saving and loading JPEG-encoded volumes.\n\n    Args:\n        array: 3D NumPy array.\n        ijk_to_ras: 4\u00d74 affine transformation matrix containing the mapping\n            from voxel indices to RAS+ (left \u2192 right, posterior \u2192 anterior,\n            inferior \u2192 superior) coordinates. If not specified, the identity\n            matrix is used.\n\n    Tip:\n        To learn more about coordinates systems, check the following resources:\n\n        - [NiBabel](https://nipy.org/nibabel/)'s [Coordinate systems and affines](https://nipy.org/nibabel/coordinate_systems.html),\n        - [3D Slicer](https://www.slicer.org/)'s [Coordinate systems](https://slicer.readthedocs.io/en/latest/user_guide/coordinate_systems.html),\n        - [FSL](https://fsl.fmrib.ox.ac.uk/)'s [docs (see \"Background information on NIfTI Orientation\")](https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/Orientation%20Explained)\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        array: npt.ArrayLike,\n        ijk_to_ras: npt.ArrayLike | None = None,\n    ):\n        self.array = np.array(array)\n        if ijk_to_ras is None:\n            ijk_to_ras = np.eye(4)\n        self.ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)\n        if self.array.ndim != 3:\n            raise ValueError(\n                f\"Array must have 3 dimensions, got shape {self.array.shape}\"\n            )\n        if self.ijk_to_ras.shape != (4, 4):\n            raise ValueError(\n                f\"ijk_to_ras must have shape (4, 4), got {self.ijk_to_ras.shape}\"\n            )\n        assert self.ijk_to_ras.shape == (4, 4)\n\n    @classmethod\n    def open(cls, path: TypePath) -&gt; JpegVolume:\n        \"\"\"Open a JVol file.\n\n        Args:\n            path: Path to a file with `'.jvol'` extension.\n        \"\"\"\n        path = Path(path)\n        if not path.is_file():\n            raise FileNotFoundError(f'File not found: \"{path}\"')\n        if path.suffix != \".jvol\":\n            raise ValueError(f'File must have .jvol extension, got \"{path}\"')\n\n        return cls(*open_jvol(path))\n\n    def save(self, path: TypePath, block_size: int = 8, quality: int = 60) -&gt; None:\n        \"\"\"Save the image using a lossy encoding algorithm for compression.\n\n        Args:\n            path: Output path with `.jvol` extension.\n            block_size: Size of the blocks to use for encoding. Higher\n                values result in better quality, but larger file sizes.\n            quality: Quality of the JPEG encoding, between 1 and 100. Higher\n                values result in better quality, but larger file sizes.\n\n        Raises:\n            ValueError: If the quality is not an integer between 1 and 100.\n            ValueError: If the block size is not a positive integer.\n        \"\"\"\n        if quality != int(quality):\n            raise ValueError(f\"Quality must be an integer, got {quality}\")\n        if not 1 &lt;= quality &lt;= 100:\n            raise ValueError(f\"Quality must be between 1 and 100, got {quality}\")\n\n        if block_size != int(block_size):\n            raise ValueError(f\"Block size must be an integer, got {block_size}\")\n        if block_size &lt;= 0:\n            raise ValueError(f\"Block size must be positive, got {block_size}\")\n\n        path = Path(path)\n\n        save_jvol(\n            self.array,\n            self.ijk_to_ras,\n            path,\n            block_size=block_size,\n            quality=quality,\n        )\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        # Get attribute from the JpegVolume or the underlying array\n        try:\n            return super().__getattribute__(name)\n        except AttributeError as e:\n            try:\n                return getattr(self.array, name)\n            except AttributeError:\n                raise e\n</code></pre>"},{"location":"reference/jvol/#jvol.JpegVolume.array","title":"<code>array = np.array(array)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jvol/#jvol.JpegVolume.ijk_to_ras","title":"<code>ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jvol/#jvol.JpegVolume.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"Source code in <code>src/jvol/jvol.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; Any:\n    # Get attribute from the JpegVolume or the underlying array\n    try:\n        return super().__getattribute__(name)\n    except AttributeError as e:\n        try:\n            return getattr(self.array, name)\n        except AttributeError:\n            raise e\n</code></pre>"},{"location":"reference/jvol/#jvol.JpegVolume.__init__","title":"<code>__init__(array, ijk_to_ras=None)</code>","text":"Source code in <code>src/jvol/jvol.py</code> <pre><code>def __init__(\n    self,\n    array: npt.ArrayLike,\n    ijk_to_ras: npt.ArrayLike | None = None,\n):\n    self.array = np.array(array)\n    if ijk_to_ras is None:\n        ijk_to_ras = np.eye(4)\n    self.ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)\n    if self.array.ndim != 3:\n        raise ValueError(\n            f\"Array must have 3 dimensions, got shape {self.array.shape}\"\n        )\n    if self.ijk_to_ras.shape != (4, 4):\n        raise ValueError(\n            f\"ijk_to_ras must have shape (4, 4), got {self.ijk_to_ras.shape}\"\n        )\n    assert self.ijk_to_ras.shape == (4, 4)\n</code></pre>"},{"location":"reference/jvol/#jvol.JpegVolume.open","title":"<code>open(path)</code>  <code>classmethod</code>","text":"<p>Open a JVol file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>TypePath</code> <p>Path to a file with <code>'.jvol'</code> extension.</p> required Source code in <code>src/jvol/jvol.py</code> <pre><code>@classmethod\ndef open(cls, path: TypePath) -&gt; JpegVolume:\n    \"\"\"Open a JVol file.\n\n    Args:\n        path: Path to a file with `'.jvol'` extension.\n    \"\"\"\n    path = Path(path)\n    if not path.is_file():\n        raise FileNotFoundError(f'File not found: \"{path}\"')\n    if path.suffix != \".jvol\":\n        raise ValueError(f'File must have .jvol extension, got \"{path}\"')\n\n    return cls(*open_jvol(path))\n</code></pre>"},{"location":"reference/jvol/#jvol.JpegVolume.save","title":"<code>save(path, block_size=8, quality=60)</code>","text":"<p>Save the image using a lossy encoding algorithm for compression.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>TypePath</code> <p>Output path with <code>.jvol</code> extension.</p> required <code>block_size</code> <code>int</code> <p>Size of the blocks to use for encoding. Higher values result in better quality, but larger file sizes.</p> <code>8</code> <code>quality</code> <code>int</code> <p>Quality of the JPEG encoding, between 1 and 100. Higher values result in better quality, but larger file sizes.</p> <code>60</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quality is not an integer between 1 and 100.</p> <code>ValueError</code> <p>If the block size is not a positive integer.</p> Source code in <code>src/jvol/jvol.py</code> <pre><code>def save(self, path: TypePath, block_size: int = 8, quality: int = 60) -&gt; None:\n    \"\"\"Save the image using a lossy encoding algorithm for compression.\n\n    Args:\n        path: Output path with `.jvol` extension.\n        block_size: Size of the blocks to use for encoding. Higher\n            values result in better quality, but larger file sizes.\n        quality: Quality of the JPEG encoding, between 1 and 100. Higher\n            values result in better quality, but larger file sizes.\n\n    Raises:\n        ValueError: If the quality is not an integer between 1 and 100.\n        ValueError: If the block size is not a positive integer.\n    \"\"\"\n    if quality != int(quality):\n        raise ValueError(f\"Quality must be an integer, got {quality}\")\n    if not 1 &lt;= quality &lt;= 100:\n        raise ValueError(f\"Quality must be between 1 and 100, got {quality}\")\n\n    if block_size != int(block_size):\n        raise ValueError(f\"Block size must be an integer, got {block_size}\")\n    if block_size &lt;= 0:\n        raise ValueError(f\"Block size must be positive, got {block_size}\")\n\n    path = Path(path)\n\n    save_jvol(\n        self.array,\n        self.ijk_to_ras,\n        path,\n        block_size=block_size,\n        quality=quality,\n    )\n</code></pre>"},{"location":"reference/jvol/#jvol.open_jvol","title":"<code>open_jvol(path)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def open_jvol(path: Path) -&gt; tuple[np.ndarray, np.ndarray]:\n    loaded = np.load(path)\n    ijk_to_ras = fill_ijk_to_ras(loaded[FormatKeys.IJK_TO_RAS.value])\n    quantization_block = loaded[FormatKeys.QUANTIZATION_BLOCK.value]\n    array = decode_array(\n        dc_rle_values=loaded[FormatKeys.DC_RLE_VALUES],\n        dc_rle_counts=loaded[FormatKeys.DC_RLE_COUNTS],\n        ac_rle_values=loaded[FormatKeys.AC_RLE_VALUES],\n        ac_rle_counts=loaded[FormatKeys.AC_RLE_COUNTS],\n        quantization_block=quantization_block,\n        target_shape=loaded[FormatKeys.SHAPE],\n        intercept=loaded[FormatKeys.INTERCEPT],\n        slope=loaded[FormatKeys.SLOPE],\n        dtype=loaded[FormatKeys.DTYPE].dtype,\n    )\n    return array, ijk_to_ras\n</code></pre>"},{"location":"reference/jvol/#jvol.save_jvol","title":"<code>save_jvol(array, ijk_to_ras, path, block_size=4, quality=60)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def save_jvol(\n    array: np.ndarray,\n    ijk_to_ras: np.ndarray,\n    path: Path,\n    block_size: int = 4,\n    quality: int = 60,\n) -&gt; None:\n    block_shape = block_size, block_size, block_size\n    quantization_table = get_quantization_table(block_shape, quality)\n    dtype = array.dtype\n    intercept = array.min()\n    slope = array.max() - intercept\n    dc_rle_values, dc_rle_counts, ac_rle_values, ac_rle_counts = encode_array(\n        array,\n        quantization_table,\n    )\n\n    dc_rle_values = dc_rle_values.astype(np.min_scalar_type(dc_rle_values))\n    dc_rle_counts = dc_rle_counts.astype(np.min_scalar_type(dc_rle_counts))\n    ac_rle_values = ac_rle_values.astype(np.min_scalar_type(ac_rle_values))\n    ac_rle_counts = ac_rle_counts.astype(np.min_scalar_type(ac_rle_counts))\n\n    save_dict = {\n        FormatKeys.IJK_TO_RAS.value: ijk_to_ras[:3],\n        FormatKeys.QUANTIZATION_BLOCK.value: quantization_table,\n        FormatKeys.DC_RLE_VALUES.value: dc_rle_values,\n        FormatKeys.DC_RLE_COUNTS.value: dc_rle_counts,\n        FormatKeys.AC_RLE_VALUES.value: ac_rle_values,\n        FormatKeys.AC_RLE_COUNTS.value: ac_rle_counts,\n        FormatKeys.DTYPE.value: np.empty((), dtype=dtype),\n        FormatKeys.INTERCEPT.value: intercept,\n        FormatKeys.SLOPE.value: slope,\n        FormatKeys.SHAPE.value: np.array(array.shape, dtype=np.uint16),\n    }\n\n    with open(path, \"wb\") as f:\n        np.savez_compressed(f, **save_dict)\n</code></pre>"},{"location":"reference/jvol/decoding/","title":"decoding","text":""},{"location":"reference/jvol/decoding/#jvol.decoding.clip_to_dtype","title":"<code>clip_to_dtype(array, dtype)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>def clip_to_dtype(\n    array: npt.NDArray[DType], dtype: npt.DTypeLike\n) -&gt; npt.NDArray[DType]:\n    try:\n        iinfo = np.iinfo(dtype)\n        if array.min() &lt; iinfo.min or array.max() &gt; iinfo.max:\n            logger.warning(\n                f\"Array intensities [{array.min():.1f}, {array.max():.1f}]\"\n                f' are outside of bounds of data type \"{dtype}\"'\n                f\" [{iinfo.min}, {iinfo.max}] after inverse cosine transform.\"\n                f\" Clipping...\"\n            )\n            array = np.clip(array, iinfo.min, iinfo.max)\n    except ValueError:\n        pass\n    return array\n</code></pre>"},{"location":"reference/jvol/decoding/#jvol.decoding.crop_array","title":"<code>crop_array(array, target_shape)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>def crop_array(\n    array: npt.NDArray[DType],\n    target_shape: TypeShapeArray,\n) -&gt; npt.NDArray[DType]:\n    if tuple(target_shape) == array.shape:\n        return array\n    logger.info(f\"Cropping array from {array.shape} to {target_shape}...\")\n    i, j, k = target_shape\n    return array[:i, :j, :k]\n</code></pre>"},{"location":"reference/jvol/decoding/#jvol.decoding.decode_array","title":"<code>decode_array(dc_rle_values, dc_rle_counts, ac_rle_values, ac_rle_counts, quantization_block, target_shape, intercept, slope, dtype)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef decode_array(\n    dc_rle_values: npt.NDArray[np.int32],\n    dc_rle_counts: npt.NDArray[np.uint32],\n    ac_rle_values: npt.NDArray[np.int32],\n    ac_rle_counts: npt.NDArray[np.uint32],\n    quantization_block: npt.NDArray[np.uint16],\n    target_shape: TypeShapeArray,\n    intercept: float,\n    slope: float,\n    dtype: npt.DTypeLike,\n) -&gt; npt.NDArray[Any]:\n    logger.info(f\"Decoding {len(dc_rle_values):,} DC RLE values...\")\n    dc_scanned_sequence = run_length_decode(dc_rle_values, dc_rle_counts)\n    logger.info(f\"Decoding {len(ac_rle_values):,} AC RLE values...\")\n    ac_scanned_sequence = run_length_decode(ac_rle_values, ac_rle_counts)\n\n    logger.info(\n        f\"Reconstructing blocks from {len(dc_scanned_sequence):,} DC components\"\n        f\" and {len(ac_scanned_sequence):,} AC components...\"\n    )\n    block_shape_array = np.array(quantization_block.shape, block_shape_dtype)\n    scanning_indices = get_scan_indices_block(block_shape_array)\n\n    dct_blocks = sequence_to_blocks(\n        dc_scanned_sequence,\n        ac_scanned_sequence,\n        scanning_indices,\n    )\n\n    logger.info(f\"Computing inverse cosine transform of {len(dct_blocks):,} blocks...\")\n    array_raw = inverse_cosine_transform(\n        dct_blocks,\n        quantization_block,\n        target_shape,\n    )\n    logger.info(\"Rescaling array intensities...\")\n    array_rescaled = rescale_array_for_decoding(array_raw, intercept, slope)\n\n    array_cropped = crop_array(array_rescaled, target_shape)\n    array_cropped = clip_to_dtype(array_cropped, dtype)\n\n    if array_cropped.dtype != dtype:\n        logger.info(f'Casting array to data type \"{repr(dtype)}\"...')\n        array_cropped = array_cropped.astype(dtype)\n\n    logger.success(\"Array decoded successfully\")\n    return array_cropped\n</code></pre>"},{"location":"reference/jvol/decoding/#jvol.decoding.inverse_cosine_transform","title":"<code>inverse_cosine_transform(dct_blocks, quantization_block, target_shape)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef inverse_cosine_transform(\n    dct_blocks: npt.NDArray[np.int32],\n    quantization_block: npt.NDArray[np.uint16],\n    target_shape: TypeShapeArray,\n) -&gt; npt.NDArray[np.float32]:\n    dct_blocks = dct_blocks.astype(float)\n    quantization_block = quantization_block.astype(float)\n    dct_blocks_rescaled = dct_blocks * quantization_block\n    blocks = idctn(dct_blocks_rescaled, axes=(-3, -2, -1))\n    blocks_array = np.array(blocks, dtype=np.float32)\n    block_shape = np.array(quantization_block.shape, block_shape_dtype)\n    padded_target_shape = pad_image_shape(target_shape, block_shape)\n    num_blocks_ijk = (padded_target_shape / block_shape).astype(int)\n    if len(blocks) != np.prod(num_blocks_ijk):\n        raise RuntimeError(\n            f\"Number of blocks ({len(blocks)}) does not match\"\n            f\" number of blocks ({num_blocks_ijk}) implied by target shape\"\n            f\" ({num_blocks_ijk}, i.e., {np.prod(num_blocks_ijk)} blocks)\"\n        )\n    array_reconstructed = rearrange(\n        blocks_array,\n        \"(i1 j1 k1) i2 j2 k2 -&gt; (i1 i2) (j1 j2) (k1 k2)\",\n        i1=num_blocks_ijk[0],\n        j1=num_blocks_ijk[1],\n        k1=num_blocks_ijk[2],\n    )\n    return array_reconstructed\n</code></pre>"},{"location":"reference/jvol/decoding/#jvol.decoding.pad_image_shape","title":"<code>pad_image_shape(image_shape, block_shape)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>def pad_image_shape(\n    image_shape: TypeShapeArray,\n    block_shape: TypeShapeBlockNumpy,\n) -&gt; TypeShapeArray:\n    padding = block_shape - image_shape % block_shape\n    padding[padding == block_shape] = 0\n    return image_shape + padding\n</code></pre>"},{"location":"reference/jvol/decoding/#jvol.decoding.rescale_array_for_decoding","title":"<code>rescale_array_for_decoding(array, intercept, slope)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef rescale_array_for_decoding(\n    array: npt.NDArray[np.float32],\n    intercept: float,\n    slope: float,\n) -&gt; npt.NDArray[np.float32]:\n    array_rescaled = array.astype(np.float32)\n    array_rescaled += 128\n    array_rescaled /= 255\n    array_rescaled *= slope\n    array_rescaled += intercept\n    return array_rescaled\n</code></pre>"},{"location":"reference/jvol/decoding/#jvol.decoding.run_length_decode","title":"<code>run_length_decode(values, counts)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef run_length_decode(\n    values: TypeRleValues,\n    counts: TypeRleCounts,\n) -&gt; npt.NDArray[np.int32]:\n    return np.repeat(values, counts)\n</code></pre>"},{"location":"reference/jvol/decoding/#jvol.decoding.sequence_to_blocks","title":"<code>sequence_to_blocks(dc_sequence, ac_sequence, indices_block)</code>","text":"Source code in <code>src/jvol/decoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef sequence_to_blocks(\n    dc_sequence: npt.NDArray[DType],\n    ac_sequence: npt.NDArray[DType],\n    indices_block: npt.NDArray[np.uint8],\n) -&gt; npt.NDArray[DType]:\n    num_elements_block = len(indices_block)\n\n    block_size = np.cbrt(num_elements_block)\n    assert block_size.is_integer()\n    block_size = int(block_size)\n\n    num_blocks = len(dc_sequence)\n\n    block_shape = block_size, block_size, block_size\n    blocks_shape = num_blocks, *block_shape\n    blocks = np.zeros(blocks_shape, dtype=dc_sequence.dtype)\n\n    blocks[:, 0, 0, 0] = dc_sequence\n\n    seq_index = 0\n    for index in indices_block[1:]:\n        values_from_sequence = ac_sequence[seq_index : seq_index + num_blocks]\n        blocks[:, index[0], index[1], index[2]] = values_from_sequence\n        seq_index += num_blocks\n\n    return blocks\n</code></pre>"},{"location":"reference/jvol/encoding/","title":"encoding","text":""},{"location":"reference/jvol/encoding/#jvol.encoding.blocks_to_sequence","title":"<code>blocks_to_sequence(dct_blocks, scan_indices)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef blocks_to_sequence(\n    dct_blocks: npt.NDArray[np.int32],\n    scan_indices: npt.NDArray[np.uint8],\n) -&gt; tuple[npt.NDArray[np.int32], npt.NDArray[np.int32]]:\n    dc_sequence = dct_blocks[:, 0, 0, 0]\n    ac_sequence = np.empty(dct_blocks.size - len(dc_sequence), dtype=np.int32)\n    for i, index in enumerate(scan_indices[1:]):\n        scanned = dct_blocks[:, index[0], index[1], index[2]]\n        ini = i * len(dct_blocks)\n        fin = ini + len(dct_blocks)\n        ac_sequence[ini:fin] = scanned\n    assert len(dc_sequence) + len(ac_sequence) == dct_blocks.size\n    return dc_sequence, ac_sequence\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.cosine_transform","title":"<code>cosine_transform(blocks)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef cosine_transform(blocks: npt.ArrayLike) -&gt; npt.NDArray[np.float64]:\n    blocks_cast = np.array(blocks, np.float64).copy()\n    blocks_cast -= blocks_cast.min()\n    blocks_cast /= blocks_cast.max()\n    blocks_cast *= 255\n    blocks_cast -= 128\n    dct_blocks = dctn(blocks_cast, axes=(-3, -2, -1))\n    return np.array(dct_blocks)\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.encode_array","title":"<code>encode_array(array, quantization_table)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef encode_array(\n    array: npt.NDArray[DType],\n    quantization_table: npt.NDArray[np.float32],\n) -&gt; tuple[TypeRleValues, TypeRleCounts, TypeRleValues, TypeRleCounts]:\n    logger.info(f\"Encoding array of shape {array.shape}...\")\n\n    block_shape_tuple = quantization_table.shape\n    block_shape_array = np.array(block_shape_tuple, block_shape_dtype)\n    padded_array = pad_array(array, block_shape_array)\n\n    blocks = split_into_blocks(padded_array, block_shape_array)\n    logger.info(f\"Array split into {len(blocks):,} blocks\")\n    dct_blocks = cosine_transform(blocks)\n    dct_blocks_quantized = quantize(dct_blocks, quantization_table)\n\n    scan_indices = get_scan_indices_block(block_shape_array)\n    dc_sequence, ac_sequence = blocks_to_sequence(dct_blocks_quantized, scan_indices)\n    logger.info(f\"DC sequence length: {len(dc_sequence):,}\")\n    logger.info(f\"AC sequence length: {len(ac_sequence):,}\")\n\n    dc_values, dc_counts = run_length_encode(dc_sequence)\n    logger.info(f\"Run-length encoded DC sequence length: {len(dc_values):,}\")\n    ac_values, ac_counts = run_length_encode(ac_sequence)\n    logger.info(f\"Run-length encoded AC sequence length: {len(ac_values):,}\")\n\n    return dc_values, dc_counts, ac_values, ac_counts\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.get_distance_to_origin","title":"<code>get_distance_to_origin(indices)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>def get_distance_to_origin(indices: TypeBlockIndices) -&gt; npt.NDArray[np.float64]:\n    return np.linalg.norm(indices, axis=1)\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.get_multiplier","title":"<code>get_multiplier(quality, max_multiplier=100, spread=15)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>def get_multiplier(\n    quality: int,\n    max_multiplier: float = 100,\n    spread: float = 15,\n) -&gt; float:\n    qualities = np.arange(1, 101)\n    # Exponential decay\n    multipliers = 1 + (max_multiplier - 1) * np.exp(-(qualities - 1) / spread)\n    # Rescale to [1, max_multiplier]\n    multipliers -= multipliers.min()\n    multipliers /= multipliers.max()\n    multipliers *= max_multiplier - 1\n    multipliers += 1\n    return multipliers[quality - 1]\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.get_quantization_table","title":"<code>get_quantization_table(shape, quality)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>def get_quantization_table(shape, quality: int) -&gt; npt.NDArray[np.float32]:\n    indices = np.array(list(np.ndindex(*shape)))\n    norms = np.linalg.norm(indices, axis=1)\n    norms_block = norms.reshape(shape)\n    qtm_unit = norms_block / norms_block.max()\n    qtm_min_50, qtm_max_50 = 10, 120  # min and max for quality 50 in 2D JPEG\n    qtm_range_50 = qtm_max_50 - qtm_min_50\n    qtm_50 = qtm_unit * qtm_range_50\n    qtm_50 += qtm_min_50\n    qtm = 2 * qtm_50\n    return qtm * get_multiplier(quality)\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.get_scan_indices_block","title":"<code>get_scan_indices_block(block_shape)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>def get_scan_indices_block(block_shape: TypeShapeBlockNumpy) -&gt; TypeBlockIndices:\n    block_shape_tuple = tuple(int(b) for b in block_shape)\n    indices_list = list(np.ndindex(block_shape_tuple))\n    indices_array = np.array(indices_list)\n    distances_to_origin = get_distance_to_origin(indices_array)\n    scan_indices = indices_array[np.argsort(distances_to_origin)]\n    return scan_indices.astype(np.uint8)\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.pad_array","title":"<code>pad_array(array, block_shape)</code>","text":"<p>Pad array until it's divisible by block size in all dimensions.</p> Source code in <code>src/jvol/encoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef pad_array(\n    array: npt.NDArray[DType], block_shape: TypeShapeBlockNumpy\n) -&gt; npt.NDArray[DType]:\n    \"\"\"Pad array until it's divisible by block size in all dimensions.\"\"\"\n    block_shape_tuple = tuple(int(b) for b in block_shape)\n    pad_width = []\n    needs_padding = False\n    for i in range(array.ndim):\n        if array.shape[i] % block_shape_tuple[i] == 0:\n            pad_width.append((0, 0))\n        else:\n            pad_width.append(\n                (0, block_shape_tuple[i] - (array.shape[i] % block_shape_tuple[i]))\n            )\n            needs_padding = True\n    if needs_padding:\n        logger.info(f\"Array with shape {array.shape} needs padding: {pad_width}\")\n    padded_array = np.pad(array, pad_width)\n    logger.info(f\"Padded array shape: {padded_array.shape}\")\n    return padded_array\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.quantize","title":"<code>quantize(dct_blocks, quantization_table)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef quantize(\n    dct_blocks: npt.NDArray[np.float64],\n    quantization_table: npt.NDArray[np.float32],\n) -&gt; npt.NDArray[np.int32]:\n    dct_blocks_quantized = np.round(dct_blocks / quantization_table)\n    return dct_blocks_quantized.astype(np.int32)\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.run_length_encode","title":"<code>run_length_encode(sequence)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef run_length_encode(\n    sequence: npt.NDArray[np.int32],\n) -&gt; tuple[npt.NDArray[np.int32], npt.NDArray[np.uint32]]:\n    # Adapted from https://stackoverflow.com/a/32681075/3956024\n    sequence = np.asarray(sequence)  # force numpy\n    num_symbols = len(sequence)\n    y = sequence[1:] != sequence[:-1]  # pairwise unequal (string safe)\n    indices = np.append(\n        np.where(y),  # type: ignore[reportArgumentType]\n        num_symbols - 1,\n    )  # must include last element position\n    counts = np.diff(np.append(-1, indices))  # run lengths\n    # p = np.cumsum(np.append(0, z))[:-1]  # positions\n    values = sequence[indices]\n    counts = np.array(counts, dtype=np.uint32)\n    return values, counts\n</code></pre>"},{"location":"reference/jvol/encoding/#jvol.encoding.split_into_blocks","title":"<code>split_into_blocks(array, block_shape)</code>","text":"Source code in <code>src/jvol/encoding.py</code> <pre><code>@timed()  # pyright: ignore\ndef split_into_blocks(\n    array: npt.NDArray[DType],\n    block_shape: TypeShapeBlockNumpy,\n) -&gt; npt.NDArray[DType]:\n    block_shape_list = block_shape.tolist()\n    # This assumes the array has been padded so the shape is divisible by block size\n    assert isinstance(block_shape_list, list)\n    blocks = rearrange(\n        array,\n        \"(i1 i2) (j1 j2) (k1 k2) -&gt; (i1 j1 k1) i2 j2 k2\",\n        i2=block_shape_list[0],\n        j2=block_shape_list[1],\n        k2=block_shape_list[2],\n    )\n    return blocks\n</code></pre>"},{"location":"reference/jvol/io/","title":"io","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys","title":"<code>FormatKeys</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>src/jvol/io.py</code> <pre><code>class FormatKeys(str, enum.Enum):\n    IJK_TO_RAS = \"ijk_to_ras\"\n    QUANTIZATION_BLOCK = \"quantization_block\"\n    DC_RLE_VALUES = \"dc_rle_values\"\n    DC_RLE_COUNTS = \"dc_rle_counts\"\n    AC_RLE_VALUES = \"ac_rle_values\"\n    AC_RLE_COUNTS = \"ac_rle_counts\"\n    DTYPE = \"dtype\"\n    INTERCEPT = \"intercept\"\n    SLOPE = \"slope\"\n    SHAPE = \"shape\"\n</code></pre>"},{"location":"reference/jvol/io/#jvol.io.FormatKeys.AC_RLE_COUNTS","title":"<code>AC_RLE_COUNTS = 'ac_rle_counts'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.AC_RLE_VALUES","title":"<code>AC_RLE_VALUES = 'ac_rle_values'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.DC_RLE_COUNTS","title":"<code>DC_RLE_COUNTS = 'dc_rle_counts'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.DC_RLE_VALUES","title":"<code>DC_RLE_VALUES = 'dc_rle_values'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.DTYPE","title":"<code>DTYPE = 'dtype'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.IJK_TO_RAS","title":"<code>IJK_TO_RAS = 'ijk_to_ras'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.INTERCEPT","title":"<code>INTERCEPT = 'intercept'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.QUANTIZATION_BLOCK","title":"<code>QUANTIZATION_BLOCK = 'quantization_block'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.SHAPE","title":"<code>SHAPE = 'shape'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.FormatKeys.SLOPE","title":"<code>SLOPE = 'slope'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/jvol/io/#jvol.io.fill_ijk_to_ras","title":"<code>fill_ijk_to_ras(ijk_to_ras)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def fill_ijk_to_ras(ijk_to_ras: npt.NDArray[np.float64]) -&gt; npt.NDArray[np.float64]:\n    last_row = [0, 0, 0, 1]\n    return np.vstack((ijk_to_ras, last_row))\n</code></pre>"},{"location":"reference/jvol/io/#jvol.io.open_image","title":"<code>open_image(path)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def open_image(path: Path) -&gt; tuple[np.ndarray, np.ndarray]:\n    _open = open_jvol if path.suffix == \".jvol\" else open_itk_image\n    return _open(path)\n</code></pre>"},{"location":"reference/jvol/io/#jvol.io.open_itk_image","title":"<code>open_itk_image(path)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def open_itk_image(path: Path) -&gt; tuple[np.ndarray, np.ndarray]:\n    image = itk.imread(path)\n    array = itk.array_view_from_image(image).T\n    ijk_to_ras = create_ijk_to_ras_from_itk_image(image)\n    return array, ijk_to_ras\n</code></pre>"},{"location":"reference/jvol/io/#jvol.io.open_jvol","title":"<code>open_jvol(path)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def open_jvol(path: Path) -&gt; tuple[np.ndarray, np.ndarray]:\n    loaded = np.load(path)\n    ijk_to_ras = fill_ijk_to_ras(loaded[FormatKeys.IJK_TO_RAS.value])\n    quantization_block = loaded[FormatKeys.QUANTIZATION_BLOCK.value]\n    array = decode_array(\n        dc_rle_values=loaded[FormatKeys.DC_RLE_VALUES],\n        dc_rle_counts=loaded[FormatKeys.DC_RLE_COUNTS],\n        ac_rle_values=loaded[FormatKeys.AC_RLE_VALUES],\n        ac_rle_counts=loaded[FormatKeys.AC_RLE_COUNTS],\n        quantization_block=quantization_block,\n        target_shape=loaded[FormatKeys.SHAPE],\n        intercept=loaded[FormatKeys.INTERCEPT],\n        slope=loaded[FormatKeys.SLOPE],\n        dtype=loaded[FormatKeys.DTYPE].dtype,\n    )\n    return array, ijk_to_ras\n</code></pre>"},{"location":"reference/jvol/io/#jvol.io.save_image","title":"<code>save_image(array, ijk_to_ras, path, **kwargs)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def save_image(\n    array: np.ndarray,\n    ijk_to_ras: np.ndarray,\n    path: Path,\n    **kwargs: int,\n) -&gt; None:\n    if path.suffix == \".jvol\":\n        save_jvol(array, ijk_to_ras, path, **kwargs)\n    else:\n        save_itk_image(array, ijk_to_ras, path)\n</code></pre>"},{"location":"reference/jvol/io/#jvol.io.save_itk_image","title":"<code>save_itk_image(array, ijk_to_ras, path)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def save_itk_image(array: np.ndarray, ijk_to_ras: np.ndarray, path: Path) -&gt; None:\n    image = itk.image_view_from_array(array.T.copy())\n    origin, rotation, spacing = get_itk_metadata_from_ijk_to_ras(ijk_to_ras)\n    image.SetOrigin(origin)\n    image.SetDirection(rotation)\n    image.SetSpacing(spacing)\n    itk.imwrite(image, path)\n</code></pre>"},{"location":"reference/jvol/io/#jvol.io.save_jvol","title":"<code>save_jvol(array, ijk_to_ras, path, block_size=4, quality=60)</code>","text":"Source code in <code>src/jvol/io.py</code> <pre><code>def save_jvol(\n    array: np.ndarray,\n    ijk_to_ras: np.ndarray,\n    path: Path,\n    block_size: int = 4,\n    quality: int = 60,\n) -&gt; None:\n    block_shape = block_size, block_size, block_size\n    quantization_table = get_quantization_table(block_shape, quality)\n    dtype = array.dtype\n    intercept = array.min()\n    slope = array.max() - intercept\n    dc_rle_values, dc_rle_counts, ac_rle_values, ac_rle_counts = encode_array(\n        array,\n        quantization_table,\n    )\n\n    dc_rle_values = dc_rle_values.astype(np.min_scalar_type(dc_rle_values))\n    dc_rle_counts = dc_rle_counts.astype(np.min_scalar_type(dc_rle_counts))\n    ac_rle_values = ac_rle_values.astype(np.min_scalar_type(ac_rle_values))\n    ac_rle_counts = ac_rle_counts.astype(np.min_scalar_type(ac_rle_counts))\n\n    save_dict = {\n        FormatKeys.IJK_TO_RAS.value: ijk_to_ras[:3],\n        FormatKeys.QUANTIZATION_BLOCK.value: quantization_table,\n        FormatKeys.DC_RLE_VALUES.value: dc_rle_values,\n        FormatKeys.DC_RLE_COUNTS.value: dc_rle_counts,\n        FormatKeys.AC_RLE_VALUES.value: ac_rle_values,\n        FormatKeys.AC_RLE_COUNTS.value: ac_rle_counts,\n        FormatKeys.DTYPE.value: np.empty((), dtype=dtype),\n        FormatKeys.INTERCEPT.value: intercept,\n        FormatKeys.SLOPE.value: slope,\n        FormatKeys.SHAPE.value: np.array(array.shape, dtype=np.uint16),\n    }\n\n    with open(path, \"wb\") as f:\n        np.savez_compressed(f, **save_dict)\n</code></pre>"},{"location":"reference/jvol/jvol/","title":"jvol","text":""},{"location":"reference/jvol/jvol/#jvol.jvol.TypePath","title":"<code>TypePath = Union[str, os.PathLike]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/jvol/#jvol.jvol.JpegVolume","title":"<code>JpegVolume</code>","text":"<p>Base class for saving and loading JPEG-encoded volumes.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ArrayLike</code> <p>3D NumPy array.</p> required <code>ijk_to_ras</code> <code>ArrayLike | None</code> <p>4\u00d74 affine transformation matrix containing the mapping from voxel indices to RAS+ (left \u2192 right, posterior \u2192 anterior, inferior \u2192 superior) coordinates. If not specified, the identity matrix is used.</p> <code>None</code> Tip <p>To learn more about coordinates systems, check the following resources:</p> <ul> <li>NiBabel's Coordinate systems and affines,</li> <li>3D Slicer's Coordinate systems,</li> <li>FSL's docs (see \"Background information on NIfTI Orientation\")</li> </ul> Source code in <code>src/jvol/jvol.py</code> <pre><code>class JpegVolume:\n    \"\"\"Base class for saving and loading JPEG-encoded volumes.\n\n    Args:\n        array: 3D NumPy array.\n        ijk_to_ras: 4\u00d74 affine transformation matrix containing the mapping\n            from voxel indices to RAS+ (left \u2192 right, posterior \u2192 anterior,\n            inferior \u2192 superior) coordinates. If not specified, the identity\n            matrix is used.\n\n    Tip:\n        To learn more about coordinates systems, check the following resources:\n\n        - [NiBabel](https://nipy.org/nibabel/)'s [Coordinate systems and affines](https://nipy.org/nibabel/coordinate_systems.html),\n        - [3D Slicer](https://www.slicer.org/)'s [Coordinate systems](https://slicer.readthedocs.io/en/latest/user_guide/coordinate_systems.html),\n        - [FSL](https://fsl.fmrib.ox.ac.uk/)'s [docs (see \"Background information on NIfTI Orientation\")](https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/Orientation%20Explained)\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        array: npt.ArrayLike,\n        ijk_to_ras: npt.ArrayLike | None = None,\n    ):\n        self.array = np.array(array)\n        if ijk_to_ras is None:\n            ijk_to_ras = np.eye(4)\n        self.ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)\n        if self.array.ndim != 3:\n            raise ValueError(\n                f\"Array must have 3 dimensions, got shape {self.array.shape}\"\n            )\n        if self.ijk_to_ras.shape != (4, 4):\n            raise ValueError(\n                f\"ijk_to_ras must have shape (4, 4), got {self.ijk_to_ras.shape}\"\n            )\n        assert self.ijk_to_ras.shape == (4, 4)\n\n    @classmethod\n    def open(cls, path: TypePath) -&gt; JpegVolume:\n        \"\"\"Open a JVol file.\n\n        Args:\n            path: Path to a file with `'.jvol'` extension.\n        \"\"\"\n        path = Path(path)\n        if not path.is_file():\n            raise FileNotFoundError(f'File not found: \"{path}\"')\n        if path.suffix != \".jvol\":\n            raise ValueError(f'File must have .jvol extension, got \"{path}\"')\n\n        return cls(*open_jvol(path))\n\n    def save(self, path: TypePath, block_size: int = 8, quality: int = 60) -&gt; None:\n        \"\"\"Save the image using a lossy encoding algorithm for compression.\n\n        Args:\n            path: Output path with `.jvol` extension.\n            block_size: Size of the blocks to use for encoding. Higher\n                values result in better quality, but larger file sizes.\n            quality: Quality of the JPEG encoding, between 1 and 100. Higher\n                values result in better quality, but larger file sizes.\n\n        Raises:\n            ValueError: If the quality is not an integer between 1 and 100.\n            ValueError: If the block size is not a positive integer.\n        \"\"\"\n        if quality != int(quality):\n            raise ValueError(f\"Quality must be an integer, got {quality}\")\n        if not 1 &lt;= quality &lt;= 100:\n            raise ValueError(f\"Quality must be between 1 and 100, got {quality}\")\n\n        if block_size != int(block_size):\n            raise ValueError(f\"Block size must be an integer, got {block_size}\")\n        if block_size &lt;= 0:\n            raise ValueError(f\"Block size must be positive, got {block_size}\")\n\n        path = Path(path)\n\n        save_jvol(\n            self.array,\n            self.ijk_to_ras,\n            path,\n            block_size=block_size,\n            quality=quality,\n        )\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        # Get attribute from the JpegVolume or the underlying array\n        try:\n            return super().__getattribute__(name)\n        except AttributeError as e:\n            try:\n                return getattr(self.array, name)\n            except AttributeError:\n                raise e\n</code></pre>"},{"location":"reference/jvol/jvol/#jvol.jvol.JpegVolume.array","title":"<code>array = np.array(array)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jvol/jvol/#jvol.jvol.JpegVolume.ijk_to_ras","title":"<code>ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/jvol/jvol/#jvol.jvol.JpegVolume.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"Source code in <code>src/jvol/jvol.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; Any:\n    # Get attribute from the JpegVolume or the underlying array\n    try:\n        return super().__getattribute__(name)\n    except AttributeError as e:\n        try:\n            return getattr(self.array, name)\n        except AttributeError:\n            raise e\n</code></pre>"},{"location":"reference/jvol/jvol/#jvol.jvol.JpegVolume.__init__","title":"<code>__init__(array, ijk_to_ras=None)</code>","text":"Source code in <code>src/jvol/jvol.py</code> <pre><code>def __init__(\n    self,\n    array: npt.ArrayLike,\n    ijk_to_ras: npt.ArrayLike | None = None,\n):\n    self.array = np.array(array)\n    if ijk_to_ras is None:\n        ijk_to_ras = np.eye(4)\n    self.ijk_to_ras = np.array(ijk_to_ras, dtype=np.float64)\n    if self.array.ndim != 3:\n        raise ValueError(\n            f\"Array must have 3 dimensions, got shape {self.array.shape}\"\n        )\n    if self.ijk_to_ras.shape != (4, 4):\n        raise ValueError(\n            f\"ijk_to_ras must have shape (4, 4), got {self.ijk_to_ras.shape}\"\n        )\n    assert self.ijk_to_ras.shape == (4, 4)\n</code></pre>"},{"location":"reference/jvol/jvol/#jvol.jvol.JpegVolume.open","title":"<code>open(path)</code>  <code>classmethod</code>","text":"<p>Open a JVol file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>TypePath</code> <p>Path to a file with <code>'.jvol'</code> extension.</p> required Source code in <code>src/jvol/jvol.py</code> <pre><code>@classmethod\ndef open(cls, path: TypePath) -&gt; JpegVolume:\n    \"\"\"Open a JVol file.\n\n    Args:\n        path: Path to a file with `'.jvol'` extension.\n    \"\"\"\n    path = Path(path)\n    if not path.is_file():\n        raise FileNotFoundError(f'File not found: \"{path}\"')\n    if path.suffix != \".jvol\":\n        raise ValueError(f'File must have .jvol extension, got \"{path}\"')\n\n    return cls(*open_jvol(path))\n</code></pre>"},{"location":"reference/jvol/jvol/#jvol.jvol.JpegVolume.save","title":"<code>save(path, block_size=8, quality=60)</code>","text":"<p>Save the image using a lossy encoding algorithm for compression.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>TypePath</code> <p>Output path with <code>.jvol</code> extension.</p> required <code>block_size</code> <code>int</code> <p>Size of the blocks to use for encoding. Higher values result in better quality, but larger file sizes.</p> <code>8</code> <code>quality</code> <code>int</code> <p>Quality of the JPEG encoding, between 1 and 100. Higher values result in better quality, but larger file sizes.</p> <code>60</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the quality is not an integer between 1 and 100.</p> <code>ValueError</code> <p>If the block size is not a positive integer.</p> Source code in <code>src/jvol/jvol.py</code> <pre><code>def save(self, path: TypePath, block_size: int = 8, quality: int = 60) -&gt; None:\n    \"\"\"Save the image using a lossy encoding algorithm for compression.\n\n    Args:\n        path: Output path with `.jvol` extension.\n        block_size: Size of the blocks to use for encoding. Higher\n            values result in better quality, but larger file sizes.\n        quality: Quality of the JPEG encoding, between 1 and 100. Higher\n            values result in better quality, but larger file sizes.\n\n    Raises:\n        ValueError: If the quality is not an integer between 1 and 100.\n        ValueError: If the block size is not a positive integer.\n    \"\"\"\n    if quality != int(quality):\n        raise ValueError(f\"Quality must be an integer, got {quality}\")\n    if not 1 &lt;= quality &lt;= 100:\n        raise ValueError(f\"Quality must be between 1 and 100, got {quality}\")\n\n    if block_size != int(block_size):\n        raise ValueError(f\"Block size must be an integer, got {block_size}\")\n    if block_size &lt;= 0:\n        raise ValueError(f\"Block size must be positive, got {block_size}\")\n\n    path = Path(path)\n\n    save_jvol(\n        self.array,\n        self.ijk_to_ras,\n        path,\n        block_size=block_size,\n        quality=quality,\n    )\n</code></pre>"},{"location":"reference/jvol/timer/","title":"timer","text":""},{"location":"reference/jvol/timer/#jvol.timer.timed","title":"<code>timed</code>","text":"<p>               Bases: <code>ContextDecorator</code></p> Source code in <code>src/jvol/timer.py</code> <pre><code>class timed(ContextDecorator):\n    def __init__(self, minimum_unit: str = \"milliseconds\"):\n        self._label = None\n        self._minimum_unit = minimum_unit\n\n    def __call__(self, func):\n        self._label = func.__name__\n        return super().__call__(func)\n\n    def __enter__(self):\n        self.start_time = time.perf_counter()\n        return self\n\n    def __exit__(self, *exc):\n        seconds = time.perf_counter() - self.start_time\n        delta = datetime.timedelta(seconds=seconds)\n        delta_string = humanize.precisedelta(delta, minimum_unit=self._minimum_unit)\n        logger.debug(f\"{self._label} took {delta_string}\")\n        return False\n</code></pre>"},{"location":"reference/jvol/timer/#jvol.timer.timed.__call__","title":"<code>__call__(func)</code>","text":"Source code in <code>src/jvol/timer.py</code> <pre><code>def __call__(self, func):\n    self._label = func.__name__\n    return super().__call__(func)\n</code></pre>"},{"location":"reference/jvol/timer/#jvol.timer.timed.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>src/jvol/timer.py</code> <pre><code>def __enter__(self):\n    self.start_time = time.perf_counter()\n    return self\n</code></pre>"},{"location":"reference/jvol/timer/#jvol.timer.timed.__exit__","title":"<code>__exit__(*exc)</code>","text":"Source code in <code>src/jvol/timer.py</code> <pre><code>def __exit__(self, *exc):\n    seconds = time.perf_counter() - self.start_time\n    delta = datetime.timedelta(seconds=seconds)\n    delta_string = humanize.precisedelta(delta, minimum_unit=self._minimum_unit)\n    logger.debug(f\"{self._label} took {delta_string}\")\n    return False\n</code></pre>"},{"location":"reference/jvol/timer/#jvol.timer.timed.__init__","title":"<code>__init__(minimum_unit='milliseconds')</code>","text":"Source code in <code>src/jvol/timer.py</code> <pre><code>def __init__(self, minimum_unit: str = \"milliseconds\"):\n    self._label = None\n    self._minimum_unit = minimum_unit\n</code></pre>"},{"location":"reference/jvol/transforms/","title":"transforms","text":""},{"location":"reference/jvol/transforms/#jvol.transforms.create_ijk_to_ras_from_itk_image","title":"<code>create_ijk_to_ras_from_itk_image(image)</code>","text":"Source code in <code>src/jvol/transforms.py</code> <pre><code>def create_ijk_to_ras_from_itk_image(image) -&gt; npt.NDArray[np.float64]:\n    ijk_to_lps = transforms3d.affines.compose(\n        tuple(image.GetOrigin()),\n        np.array(image.GetDirection()).reshape(3, 3),\n        tuple(image.GetSpacing()),\n    )\n    lps_to_ras = np.diag((-1, -1, 1, 1))\n    ijk_to_ras = lps_to_ras @ ijk_to_lps\n    return ijk_to_ras.astype(np.float64)\n</code></pre>"},{"location":"reference/jvol/transforms/#jvol.transforms.get_itk_metadata_from_ijk_to_ras","title":"<code>get_itk_metadata_from_ijk_to_ras(ijk_to_ras)</code>","text":"Source code in <code>src/jvol/transforms.py</code> <pre><code>def get_itk_metadata_from_ijk_to_ras(ijk_to_ras: npt.NDArray[np.float64]):\n    ras_to_lps = np.diag((-1, -1, 1, 1))\n    ijk_to_lps = ras_to_lps @ ijk_to_ras\n    origin, rotation, spacing, _ = transforms3d.affines.decompose(ijk_to_lps)\n    return origin, rotation, spacing\n</code></pre>"},{"location":"reference/jvol/types/","title":"types","text":""},{"location":"reference/jvol/types/#jvol.types.DType","title":"<code>DType = TypeVar('DType', bound=generic)</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/types/#jvol.types.TypeBlockIndices","title":"<code>TypeBlockIndices = npt.NDArray[np.uint8]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/types/#jvol.types.TypeRleCounts","title":"<code>TypeRleCounts = npt.NDArray[np.uint32]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/types/#jvol.types.TypeRleValues","title":"<code>TypeRleValues = npt.NDArray[np.int32]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/types/#jvol.types.TypeShapeArray","title":"<code>TypeShapeArray = npt.NDArray[np.uint16]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/types/#jvol.types.TypeShapeBlockNumpy","title":"<code>TypeShapeBlockNumpy = npt.NDArray[block_shape_dtype]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/types/#jvol.types.TypeShapeTuple","title":"<code>TypeShapeTuple = tuple[int, int, int]</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/types/#jvol.types.block_shape_dtype","title":"<code>block_shape_dtype = np.uint8</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/cli/","title":"cli","text":""},{"location":"reference/jvol/cli/convert/","title":"convert","text":""},{"location":"reference/jvol/cli/convert/#jvol.cli.convert.app","title":"<code>app = typer.Typer(pretty_exceptions_show_locals=False)</code>  <code>module-attribute</code>","text":""},{"location":"reference/jvol/cli/convert/#jvol.cli.convert.main","title":"<code>main(input_path=typer.Argument(..., exists=True, dir_okay=False), output_path=typer.Argument(..., dir_okay=False), quality=typer.Option(60, '--quality', '-q', min=1, max=100, help='Quality of the JPEG encoding, between 1 and 100.'), block_size=typer.Option(8, '--block-size', '-b', min=2, help='Size of the blocks to use for encoding. Quality is higher with larger blocks, but so is the file size.'), verbose=0)</code>","text":"<p>Tool for converting medical images to and from JPEG-encoded volumes.</p> Source code in <code>src/jvol/cli/convert.py</code> <pre><code>@app.command()\ndef main(\n    input_path: Path = typer.Argument(\n        ...,\n        exists=True,\n        dir_okay=False,\n    ),\n    output_path: Path = typer.Argument(\n        ...,\n        dir_okay=False,\n    ),\n    quality: int = typer.Option(\n        60,\n        \"--quality\",\n        \"-q\",\n        min=1,\n        max=100,\n        help=\"Quality of the JPEG encoding, between 1 and 100.\",\n    ),\n    block_size: int = typer.Option(\n        8,\n        \"--block-size\",\n        \"-b\",\n        min=2,\n        help=(\n            \"Size of the blocks to use for encoding.\"\n            \" Quality is higher with larger blocks, but so is the file size.\"\n        ),\n    ),\n    verbose: Annotated[\n        int,\n        typer.Option(\n            \"--verbose\",\n            \"-v\",\n            count=True,\n            help=\"Enable verbose logging. Use -vv for debug logging.\",\n        ),\n    ] = 0,\n) -&gt; None:\n    \"\"\"Tool for converting medical images to and from JPEG-encoded volumes.\"\"\"\n    setup_logging(verbose)\n\n    logger.info(f'Opening \"{input_path}\"...')\n    array, ijk_to_ras = open_image(input_path)\n    logger.debug(f\"Array shape: {array.shape}\")\n    logger.debug(\"ijk_to_ras:\")\n    for line in str(ijk_to_ras).splitlines():\n        logger.debug(f\"  {line}\")\n    logger.success(f'Opened \"{input_path}\" ({naturalsize(input_path.stat().st_size)})')\n\n    logger.info(f'Saving \"{output_path}\"...')\n    save_image(array, ijk_to_ras, output_path, quality=quality, block_size=block_size)\n    logger.success(f'Saved \"{output_path}\" ({naturalsize(output_path.stat().st_size)})')\n</code></pre>"},{"location":"reference/jvol/cli/convert/#jvol.cli.convert.setup_logging","title":"<code>setup_logging(verbosity)</code>","text":"Source code in <code>src/jvol/cli/convert.py</code> <pre><code>def setup_logging(verbosity: int):\n    logger.remove()\n    match verbosity:\n        case 0:\n            level = \"WARNING\"\n        case 1:\n            level = \"INFO\"\n        case 2:\n            level = \"DEBUG\"\n        case _:\n            level = \"TRACE\"\n\n    logger.add(sys.stderr, level=level)\n    logger.enable(\"jvol\")\n</code></pre>"}]}